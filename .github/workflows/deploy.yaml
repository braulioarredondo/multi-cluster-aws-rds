name: Test MultiK8s
on:
  push:
    branches:
      - master

env:
  SHA: $(git rev-parse HEAD)

jobs:
  Multi-cluster-deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      #- name: Build Images
        #run:  |-
        #  docker build -t braulioarredondo/multi-client-k8s:latest -t braulioarredondo/multi-client-k8s:${{ env.SHA }} -f ./client/Dockerfile ./client
        #  docker build -t braulioarredondo/multi-server-k8s:latest -t braulioarredondo/multi-server-k8s:${{ env.SHA }} -f ./server/Dockerfile ./server
        #  docker build -t braulioarredondo/multi-worker-k8s:latest -t braulioarredondo/multi-worker-k8s:${{ env.SHA }} -f ./worker/Dockerfile ./worker

      #- name: Test
        #run: |-
        #  docker login -u ${{ secrets.DOCKER_USERNAME }} -p ${{ secrets.DOCKER_PASSWORD }}
        #  docker build -t braulioarredondo/react-test -f ./client/Dockerfile.dev ./client
        #  docker run -e CI=true braulioarredondo/react-test npm test

      #- name: Push
        #run: |-
        #  docker push braulioarredondo/multi-client-k8s:latest
        #  docker push braulioarredondo/multi-server-k8s:latest
        #  docker push braulioarredondo/multi-worker-k8s:latest

        #  docker push braulioarredondo/multi-client-k8s:${{ env.SHA }}
        #  docker push braulioarredondo/multi-server-k8s:${{ env.SHA }}
        #  docker push braulioarredondo/multi-worker-k8s:${{ env.SHA }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SCRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Deploy to AWS CloudFormation
        # Cloudformation template deploys multiple roles that need the capabilites flag. 
        # We use the cloufromation command since aws-actions/aws-cloudformation-github-deploy@v1 is not compatible with capabilities flag.
        run: |-
          aws cloudformation create-stack --stack-name multi-cluster \
          --template-body file://multi-cluster.yaml \
          --parameters ParameterKey=EKSClusterName,ParameterValue=multi-cluster \
          ParameterKey=MasterUserPassword,ParameterValue=${{ secrets.PGPASSWORD }} \
          --capabilities CAPABILITY_NAMED_IAM

          aws cloudformation wait stack-create-complete --stack-name multi-cluster
          aws eks update-kubeconfig --region us-east-1 --name multi-cluster

      - name: Configure EKS Cluster
        # Installing Helm, nginx ingress, pgpassword secret, CSI Addon for ebs storage clase driver and apply k8s template configurations.
        run: |-    
          curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3
          chmod 700 get_helm.sh
          ./get_helm.sh
          
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
          helm install my-release ingress-nginx/ingress-nginx
          kubectl create secret generic pgpassword --from-literal PGPASSWORD=${{ secrets.PGPASSWORD }}

    

          APP_NAMESPACE=postgres
          kubectl create ns "${APP_NAMESPACE}"

          RDS_SUBNET_GROUP_NAME="multi-cluster-rds"
          RDS_SUBNET_GROUP_DESCRIPTION="Postgres rds subnet group for multi-cluster"
          EKS_VPC_ID=$(aws eks describe-cluster --name=multi-cluster \
            --query "cluster.resourcesVpcConfig.vpcId" \
            --output text)
          EKS_SUBNET_IDS=$(aws ec2 describe-subnets \
            --filters "Name=vpc-id,Values=${EKS_VPC_ID}" \
            --query 'Subnets[*].SubnetId' \
            --output text
          )


          cat <<-EOF > db-subnet-groups.yaml
          apiVersion: rds.services.k8s.aws/v1alpha1
          kind: DBSubnetGroup
          metadata:
            name: ${RDS_SUBNET_GROUP_NAME}
            namespace: ${APP_NAMESPACE}
          spec:
            name: ${RDS_SUBNET_GROUP_NAME}
            description: ${RDS_SUBNET_GROUP_DESCRIPTION}
            subnetIDs:
          $(printf "    - %s\n" ${EKS_SUBNET_IDS})
            tags: []
          EOF

          kubectl apply -f db-subnet-groups.yaml



          RDS_SECURITY_GROUP_NAME="multi-cluster-rds-sg"
          RDS_SECURITY_GROUP_DESCRIPTION="SG for rds multi-cluster DB instance"

          EKS_CIDR_RANGE=$(aws ec2 describe-vpcs \
            --vpc-ids $EKS_VPC_ID \
            --query "Vpcs[].CidrBlock" \
            --output text
          )

          RDS_SECURITY_GROUP_ID=$(aws ec2 create-security-group \
            --group-name "${RDS_SUBNET_GROUP_NAME}" \
            --description "${RDS_SUBNET_GROUP_DESCRIPTION}" \
            --vpc-id "${EKS_VPC_ID}" \
            --output text
          )

          aws ec2 authorize-security-group-ingress \
            --group-id "${RDS_SECURITY_GROUP_ID}" \
            --protocol tcp \
            --port 5432 \
            --cidr "${EKS_CIDR_RANGE}"

          RDS_DB_USERNAME="postgres"

          kubectl create secret generic -n "${APP_NAMESPACE}" rds-postgres-creds \
            --from-literal=username="${RDS_DB_USERNAME}" \
            --from-literal=password="${{ secrets.PGPASSWORD }}"  


          RDS_DB_INSTANCE_NAME="multi-cluster-db"
          RDS_DB_INSTANCE_CLASS="db.t3.micro"
          RDS_DB_STORAGE_SIZE=20

          cat <<-EOF > rds-db.yaml 
          apiVersion: rds.services.k8s.aws/v1alpha1
          kind: DBInstance
          metadata:
            name: ${RDS_DB_INSTANCE_NAME}
            namespace: ${APP_NAMESPACE}
          spec:
            allocatedStorage: ${RDS_DB_STORAGE_SIZE}
            autoMinorVersionUpgrade: false
            backupRetentionPeriod: 1
            dbInstanceClass: ${RDS_DB_INSTANCE_CLASS}
            dbInstanceIdentifier: ${RDS_DB_INSTANCE_NAME}
            dbName: fibvalues
            dbSubnetGroupName: ${RDS_SUBNET_GROUP_NAME}
            enablePerformanceInsights: true
            engine: postgres
            engineVersion: "15.3"
            masterUsername: ${RDS_DB_USERNAME}
            masterUserPassword:
              namespace: ${APP_NAMESPACE}
              name: rds-postgres-creds
              key: password
            multiAZ: false
            publiclyAccessible: false
            storageEncrypted: false
            storageType: gp2
            vpcSecurityGroupIDs:
              - ${RDS_SECURITY_GROUP_ID}
          EOF

          kubectl apply -f rds-db.yaml

          kubectl describe dbinstance -n "${APP_NAMESPACE}" "${RDS_DB_INSTANCE_NAME}
          kubectl get dbinstance -n "${APP_NAMESPACE}" "${RDS_DB_INSTANCE_NAME}" \
          -o jsonpath='{.status.dbInstanceStatus}

          RDS_DB_INSTANCE_HOST=$(kubectl get dbinstance -n "${APP_NAMESPACE}" "${RDS_DB_INSTANCE_NAME}" \
          -o jsonpath='{.status.endpoint.address}')
          RDS_DB_INSTANCE_PORT=$(kubectl get dbinstance -n "${APP_NAMESPACE}" "${RDS_DB_INSTANCE_NAME}" \
          -o jsonpath='{.status.endpoint.port}')
          

          REDISIDENTIFIER="multi-cluster-redis"
          REDIS_ENDPOINT_ADDRESS=$(aws elasticache describe-cache-clusters \
          --cache-cluster-id $REDISIDENTIFIER \
          --show-cache-node-info \
          --query 'CacheClusters[].CacheNodes[].Endpoint[].Address' \
          --output text)

          sleep 600s

          cat server-deployment.yaml | sed -e "s/{{RDS_DB_USERNAME}}/$RDS_DB_USERNAME/g; s/{{RDS_DB_INSTANCE_HOST}}/$RDS_DB_INSTANCE_HOST/g; \ 
          s/{{RDS_DB_INSTANCE_PORT}}/$RDS_DB_INSTANCE_PORT/g; s/{{REDIS_ENDPOINT_ADDRESS}}/$REDIS_ENDPOINT_ADDRESS/g" | kubectl apply -f -

          cat worker-deployment.yaml | sed -e "s/{{REDIS_ENDPOINT_ADDRESS}}/$REDIS_ENDPOINT_ADDRESS/g" | kubectl apply -f -


          kubectl apply -f ./k8s/

          sleep 180s

      - name: Get Ingress URL
        # Get EKS Ingress Service URL
        run: |-   
          kubectl get service my-release-ingress-nginx-controller